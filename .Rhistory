# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
tictoc::tic()
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
tictoc::toc()
result$m
# compare to home rolled vsvb
dp_result = epwpl::vb_wlr(X, y, result$sigma0, p0, result$v_slab, max_iter = 200)
dp_result
1e-5
1e-5 * 1
library(epwpl)
# compare to home rolled vsvb
dp_result = epwpl::vb_wlr(X, y, result$sigma0, p0, result$v_slab, max_iter = 200)
library(epwpl)
# compare to home rolled vsvb
dp_result = epwpl::vb_wlr(X, y, result$sigma0, p0, result$v_slab, max_iter = 200)
library(epwpl)
# compare to home rolled vsvb
dp_result = epwpl::vb_wlr(X, y, result$sigma0, p0, result$v_slab, max_iter = 200)
mu
alpha
muX
X
y
dim(X)
length(X)
y
length(y)
library(epwpl)
# compare to home rolled vsvb
dp_result = epwpl::vb_wlr(X, y, result$sigma0, p0, result$v_slab, max_iter = 200)
dp_result
elbo_opt
library(epwpl)
# compare to home rolled vsvb
dp_result = epwpl::vb_wlr(X, y, result$sigma0, p0, result$v_slab, max_iter = 200)
dp_result
library(epwpl)
# compare to home rolled vsvb
dp_result = epwpl::vb_wlr(X, y, result$sigma0, p0, result$v_slab, max_iter = 200)
dp_result
library(epwpl)
# compare to home rolled vsvb
dp_result = epwpl::vb_wlr(X, y, result$sigma0, p0, result$v_slab, max_iter = 200)
dp_result
library(epwpl)
# compare to home rolled vsvb
dp_result = epwpl::vb_wlr(X, y, result$sigma0, p0, result$v_slab, max_iter = 200)
mu_old
logit_alpha_old
alpha_old
mu\
mu
alpha
logit_alpha
logit_alpha
alpha
alpha
p0
qlogis(p0)
log(p0 / (1 - p0))
elbo_opt
source('~/Research/ep_weighted_pseduolikelihood/R/cov_vsvb.R')
elbo
library(epwpl)
library(epwpl)
dp_result = epwpl::vb_wlr(X, y, result$sigma0, p0, result$v_slab,
mu_init = w,
max_iter = 200)
mu_old
mu
mu]
mu
logit_alpha
alpha
mu
library(epwpl)
dp_result = epwpl::vb_wlr(X, y, result$sigma0, p0, result$v_slab,
mu_init = w,
max_iter = 200)
dp_result
library(epwpl)
dp_result = epwpl::vb_wlr(X, y, result$sigma0, p0, result$v_slab,
mu_init = w,
max_iter = 200)
dp_result
dp_result = epwpl::vb_wlr(X, y, sigma0, p0, result$v_slab,
mu_init = w,
max_iter = 200)
dp_result
dp_result = epwpl::vb_wlr(X, y, result$sigma0, p0, result$v_slab,
mu_init = w,
max_iter = 200)
dp_result
dp_result = epwpl::vb_wlr(X, y, result$sigma0, p0, result$v_slab,
mu_init = rep(0, d),
max_iter = 200)
dp_result = epwpl::vb_wlr(X, y, result$sigma0, p0, result$v_slab,
mu_init = rep(0, d+1),
max_iter = 200)
dp_result
logit_alpha
dp_result$logit_alpha
plogis(dp_result$logit_alpha)
n = 1000
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
tictoc::tic()
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
tictoc::toc()
result$m
# compare to home rolled vsvb
dp_result = epwpl::vb_wlr(X, y, result$sigma0, p0, result$v_slab,
mu_init = rep(0, d+1),
max_iter = 200)
dp_result
library(epwpl)
dp_result = epwpl::vb_wlr(X, y, result$sigma0, p0, result$v_slab,
mu_init = rep(0, d+1),
max_iter = 200)
dp_result
dp_result = epwpl::vb_wlr(X, y, result$sigma0, p0, result$v_slab,
mu_init = w,
max_iter = 200)
dp_result
library(epwpl)
dp_result = epwpl::vb_wlr(X, y, result$sigma0, p0, result$v_slab,
mu_init = rep(0, d+1),
max_iter = 200)
dp_result
library(epwpl)
dp_result = epwpl::vb_wlr(X, y, result$sigma0, p0, result$v_slab,
mu_init = rep(0, d+1),
max_iter = 200)
dp_result
result$approx_mlik
result$p
plogis(result$p()
)
plogis(result$p)
result$v
sqrt(result$v)
dp_result$var
sqrt(dp_result$var)
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
set.seed(1)
n = 100
p = 10
Lam1 = c(3, 3, 3, 3, rep(0, p-3)) * 5 # For Z[i]=-0.1
Lam2 = Lam1 #Same lambda for both covariate levels, corresponds to covariate independent levels
Var1 = solve(Lam1 %*% t(Lam1) + diag(rep(10, p+1))) #covariance matrix for covariate level 1
Var2 = solve(Lam2 %*% t(Lam2) + diag(rep(10, p+1))) #covariance matrix for covariate level 2
# covariate matrix
Z = matrix(-.1*(1:n <= n/2)  + .1*(1:n > n/2), nrow = n, ncol = p, byrow = FALSE)
# true graph
true_graph = matrix(0, p+1, p+1)
for(i in 1:(p+1)){
for(j in 1:(p+1)){
true_graph[i,j] = (Lam1[i] != 0 & Lam1[j] != 0)
}}
diag(true_graph) = 0
# compute weights
tau = 1  # bandwidth
weight_mat = weight_matrix(n, Z)
# only two covariate levels --> only two weightings
weight_mat_fit = weight_mat[c(1, n), ]
# initial hyperparameter values
sigma0 = 1
p0 = .2
v_slab = 3
n_sim = 50
graphs = wpl_regression(data_mat, weight_mat_fit, sigma0, p0, v_slab, n_threads = 1,
blas_threads = 1)
graphs_vb = wpl_vsvb_regression(data_mat, weight_mat, sigma0, p0, v_slab)
library(epwpl)
graphs = wpl_regression(data_mat, weight_mat_fit, sigma0, p0, v_slab, n_threads = 1,
blas_threads = 1)
library(epwpl)
tictoc::tic()
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
tictoc::toc()
result$m
d = 10
n = 1000
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
d = 10
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
tictoc::tic()
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
tictoc::toc()
result$m
result
set.seed(1)
n = 100
p = 10
Lam1 = c(3, 3, 3, 3, rep(0, p-3)) * 5 # For Z[i]=-0.1
Lam2 = Lam1 #Same lambda for both covariate levels, corresponds to covariate independent levels
Var1 = solve(Lam1 %*% t(Lam1) + diag(rep(10, p+1))) #covariance matrix for covariate level 1
Var2 = solve(Lam2 %*% t(Lam2) + diag(rep(10, p+1))) #covariance matrix for covariate level 2
# covariate matrix
Z = matrix(-.1*(1:n <= n/2)  + .1*(1:n > n/2), nrow = n, ncol = p, byrow = FALSE)
# true graph
true_graph = matrix(0, p+1, p+1)
for(i in 1:(p+1)){
for(j in 1:(p+1)){
true_graph[i,j] = (Lam1[i] != 0 & Lam1[j] != 0)
}}
diag(true_graph) = 0
# compute weights
tau = 1  # bandwidth
weight_mat = weight_matrix(n, Z)
# only two covariate levels --> only two weightings
weight_mat_fit = weight_mat[c(1, n), ]
# initial hyperparameter values
sigma0 = 1
p0 = .2
v_slab = 3
n_sim = 50
X
Z
weight_mat_fit
graphs = wpl_regression(data_mat, weight_mat_fit, sigma0, p0, v_slab, n_threads = 1,
blas_threads = 1)
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
graphs = wpl_regression(data_mat, weight_mat_fit, sigma0, p0, v_slab, n_threads = 1,
blas_threads = 1)
X_weighted
View(X_weighted)
sigma0
View(sigma0)
View(p0)
View(v_slab)
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
library(epwpl)
graphs = wpl_regression(data_mat, weight_mat_fit, sigma0, p0, v_slab, n_threads = 1,
blas_threads = 1)
sigma0
View(sigma0)
graphs = wpl_regression(data_mat, weight_mat_fit, sigma0, p0, v_slab, n_threads = 1,
blas_threads = 1)
library(epwpl)
graphs = wpl_regression(data_mat, weight_mat_fit, sigma0, p0, v_slab, n_threads = 1,
blas_threads = 1)
graphs = wpl_regression(data_mat, weight_mat_fit, sigma0, p0, v_slab, n_threads = 1,
blas_threads = 1)
View(yty)
hyper_opt = dfoptim::nmkb(c(sigma0, v_slab), hyper_obj,
lower = c(0, 0), upper = c(Inf, Inf),
n = n, tmtXy = tmtXy, yty = yty, In = In,
XV_tX = XV_tX,
sigm_p_site3 = sigm_p_site3,
sigm_mp_site3_dnorm = sigm_mp_site3_dnorm,
m_site1 = m_site1, v_site1 = v_site1)
set.seed(1)
n = 100
p = 10
Lam1 = c(3, 3, 3, 3, rep(0, p-3)) * 5 # For Z[i]=-0.1
Lam2 = Lam1 #Same lambda for both covariate levels, corresponds to covariate independent levels
Var1 = solve(Lam1 %*% t(Lam1) + diag(rep(10, p+1))) #covariance matrix for covariate level 1
Var2 = solve(Lam2 %*% t(Lam2) + diag(rep(10, p+1))) #covariance matrix for covariate level 2
# covariate matrix
Z = matrix(-.1*(1:n <= n/2)  + .1*(1:n > n/2), nrow = n, ncol = p, byrow = FALSE)
# true graph
true_graph = matrix(0, p+1, p+1)
for(i in 1:(p+1)){
for(j in 1:(p+1)){
true_graph[i,j] = (Lam1[i] != 0 & Lam1[j] != 0)
}}
diag(true_graph) = 0
# compute weights
tau = 1  # bandwidth
weight_mat = weight_matrix(n, Z)
# only two covariate levels --> only two weightings
weight_mat_fit = weight_mat[c(1, n), ]
# initial hyperparameter values
sigma0 = 1
p0 = .2
v_slab = 3
n_sim = 50
# library(future.apply)
library(data.table)
source("experiment/simulation.R")
setDTthreads(1)
X1 = MASS::mvrnorm(n/2, rep(0, p+1), Var1)
X2 = MASS::mvrnorm(n/2, rep(0, p+1), Var2)
data_mat = rbind(X1, X2)
graphs = wpl_regression(data_mat, weight_mat_fit, sigma0, p0, v_slab, n_threads = 1,
blas_threads = 1)
set.seed(1)
n = 100
p = 10
Lam1 = c(3, 3, 3, 3, rep(0, p-3)) * 5 # For Z[i]=-0.1
Lam2 = Lam1 #Same lambda for both covariate levels, corresponds to covariate independent levels
Var1 = solve(Lam1 %*% t(Lam1) + diag(rep(10, p+1))) #covariance matrix for covariate level 1
Var2 = solve(Lam2 %*% t(Lam2) + diag(rep(10, p+1))) #covariance matrix for covariate level 2
# covariate matrix
Z = matrix(-.1*(1:n <= n/2)  + .1*(1:n > n/2), nrow = n, ncol = p, byrow = FALSE)
# true graph
true_graph = matrix(0, p+1, p+1)
for(i in 1:(p+1)){
for(j in 1:(p+1)){
true_graph[i,j] = (Lam1[i] != 0 & Lam1[j] != 0)
}}
diag(true_graph) = 0
# compute weights
tau = 1  # bandwidth
weight_mat = weight_matrix(n, Z)
# only two covariate levels --> only two weightings
weight_mat_fit = weight_mat[c(1, n), ]
# initial hyperparameter values
sigma0 = 1
p0 = .2
v_slab = 3
n_sim = 50
# simulate the data for this iteration
X1 = MASS::mvrnorm(n/2, rep(0, p+1), Var1)
X2 = MASS::mvrnorm(n/2, rep(0, p+1), Var2)
data_mat = rbind(X1, X2)
graphs = wpl_regression(data_mat, weight_mat_fit, sigma0, p0, v_slab, n_threads = 1,
blas_threads = 1)
library(epwpl)
graphs = wpl_regression(data_mat, weight_mat_fit, sigma0, p0, v_slab, n_threads = 1,
blas_threads = 1)
# library(future.apply)
library(data.table)
source("experiment/simulation.R")
setDTthreads(1)
set.seed(1)
n = 100
p = 10
Lam1 = c(3, 3, 3, 3, rep(0, p-3)) * 5 # For Z[i]=-0.1
Lam2 = Lam1 #Same lambda for both covariate levels, corresponds to covariate independent levels
Var1 = solve(Lam1 %*% t(Lam1) + diag(rep(10, p+1))) #covariance matrix for covariate level 1
Var2 = solve(Lam2 %*% t(Lam2) + diag(rep(10, p+1))) #covariance matrix for covariate level 2
# covariate matrix
Z = matrix(-.1*(1:n <= n/2)  + .1*(1:n > n/2), nrow = n, ncol = p, byrow = FALSE)
# true graph
true_graph = matrix(0, p+1, p+1)
for(i in 1:(p+1)){
for(j in 1:(p+1)){
true_graph[i,j] = (Lam1[i] != 0 & Lam1[j] != 0)
}}
diag(true_graph) = 0
# compute weights
tau = 1  # bandwidth
weight_mat = weight_matrix(n, Z)
# only two covariate levels --> only two weightings
weight_mat_fit = weight_mat[c(1, n), ]
# initial hyperparameter values
sigma0 = 1
p0 = .2
v_slab = 3
n_sim = 50
X1 = MASS::mvrnorm(n/2, rep(0, p+1), Var1)
X2 = MASS::mvrnorm(n/2, rep(0, p+1), Var2)
data_mat = rbind(X1, X2)
graphs = wpl_regression(data_mat, weight_mat_fit, sigma0, p0, v_slab, n_threads = 1,
blas_threads = 1)
d = 10
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
tictoc::tic()
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
tictoc::toc()
result$m
library(epwpl)
d = 10
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
tictoc::tic()
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
tictoc::toc()
result$m
library(epwpl)
d = 10
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
tictoc::tic()
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
tictoc::toc()
result$m
d = 10
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
tictoc::tic()
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
tictoc::toc()
result$m
library(epwpl)
d = 10
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
tictoc::tic()
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
tictoc::toc()
result$m
d = 10
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
tictoc::tic()
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
tictoc::toc()
result$m
X
y
