for (resp_index in 1:(p+1)) {
for (i in 1:n) {
beta[i, ] = (t(Lam1[-resp_index]) > 0) * (i <= n/2) +
(t(Lam2[-resp_index]) > 0) * (i > n/2) #Ground truth
for(j in 1:p){
Z[i,j] = -.1*(i <= n/2)  + .1*(i > n/2)
}
}
y = data_mat[, resp_index] #Set variable number `resp_index` as the response
X_mat = data_mat[, -resp_index]
X_vec = matrix(0, n*p, 1)
X = matrix(rep(0, n^2*p), nrow = n, ncol = n*p)
for(i in 1:n) {
for(j in 1:p) {
k = p*(i-1) + 1
X[i, k+j-1] = X_mat[i, j]
X_vec[k+j-1] = X[i, k+j-1]
}
}
ELBO_LBit=rep(0,10000)
Big_diag_mat <- matrix(rep(0,n^2*p),nrow=n,ncol=n*p)
for(i in 1:n){
k=p*(i-1)
for(j in 1:p){
Big_diag_mat[i,k+j]=1
}
}
q = matrix(2, n, 1)
sigmasq = 1 #Initialization of the hyperparameter value
E <- rnorm(n, 0, sigmasq)
# compute weights
XtX = t(X) %*% X
DXtX = diag(XtX)
DXtX_rep = rep(DXtX, p)
DXtX_mat = matrix(DXtX_rep, n*p, p, byrow=FALSE)
Diff_mat = XtX - diag(DXtX)
D = matrix(1, n, n)
for(i in 1:n){
for(j in 1:n){
D[i, j] = dnorm(norm(Z[i, ] - Z[j, ], "2"), 0, .1)
}
}
for(i in 1:n){
D[, i] = n * (D[, i] / sum(D[, i])) #Scaling the weights so that they add up to n
# D[,i]=1 # When there is no covariate information, set the weights to be 1 throughout.
}
alpha = rep(0.2, n*p) #Initialization of the inclusion probability matrix for a fixed variable, with i th row corresponding to i th subject.
sigmabeta_sq = 3 #Initialization for hyperparameter
mu = rep(0, p) # Variational parameter
true_pi = 0.5 #Hyperparameter
y_long_vec = as.vector(t(y %*% matrix(1, 1, p)))
Xty=t(X) %*% as.vector(y)
beta_mat = matrix(beta, n, p, byrow=TRUE)
mu_mat = beta_mat
D_long = matrix(0, n*p, n)
for( i in 1:n){
D_long[, i] = matrix(t(D[, i] %*% matrix(1, 1, p)), n*p, 1)
}
S_sq = matrix(sigmasq*(DXtX + 1/sigmabeta_sq)^(-1), n, p) #Initialization
iter = 1
ind_vec = seq(0,(n-1)*p,by=p)
Ind_mat = matrix(0,n,p)
for(j in 1:p){
Ind_mat[, j] = ind_vec + j
}
Big_ind = matrix(0, n*p, p)
Big_ind_1 = matrix(0, n*p, p)
for(j in 1:p){
Big_ind[Ind_mat[, j], j] = 1
Big_ind_1[Ind_mat[, j], j] = 0
}
DXtX_Big_ind = DXtX_mat * Big_ind
candL = seq(0.1, 0.9, .2)# Different values of hyperparameter true_pi
#candL=0.5
like = rep(0, length(candL))
elb = like
est_pi = rep(0, n)
est_q = est_pi
beta_matr = matrix(0, n, p)
####################tuning hyperparameters##################################
idmod = varbvs::varbvs(X_mat, y, Z=Z[, 1], verbose = FALSE)#Setting hyperparameter value as in Carbonetto Stephens model
inprob = idmod$pip
rest_index_set = setdiff(c(1:(p+1)), resp_index)
sigmasq = mean(idmod$sigma)
pi_est = mean(1 / (1 + exp(-idmod$logodds)))
sigmavec = c(0.01, 0.05, 0.1, 0.5, 1, 3, 7, 10)
elb1 = matrix(0, length(sigmavec), 1)
for (j in 1:length(sigmavec)) {
res = epwpl::cov_vsvb(y, X, Z, XtX, DXtX, Diff_mat, Xty, sigmasq, sigmavec[j], pi_est)
elb1[j] = res$var.elbo
}
sigmabeta_sq = sigmavec[which.max(elb1)] #Choosing hyperparameter based on ELBO maximization
result = cov_vsvb(y, X, Z, XtX, DXtX, Diff_mat, Xty, sigmasq, sigmabeta_sq, pi_est)
incl_prob = result$var.alpha
mu0_val = result$var.mu0_lambda
heat_alpha = matrix(incl_prob, n, p, byrow=TRUE)
mylist[[resp_index]] = heat_alpha
}
library(epwpl)
library(epwpl)
d = 10
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
tictoc::tic()
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
tictoc::toc()
result$m
dp_result = epwpl::cov_vsvb(X, y, alpha0 = .2, sigmabeta_sq = v_slab,
true_pi = p0)
y
X
dp_result = epwpl::cov_vsvb(X, y, alpha0 = .2, sigmabeta_sq = v_slab,
true_pi = p0)
library(epwpl)
dp_result = epwpl::cov_vsvb(X, y, alpha0 = .2, sigmabeta_sq = v_slab,
true_pi = p0)
y_long_vec = as.vector(t(y %*% matrix(1, 1, p)))
Xty=t(X) %*% as.vector(y)
library(epwpl)
# compare to home rolled vsvb
dp_result = epwpl::cov_vsvb(X, y, alpha0 = .2, sigmabeta_sq = v_slab,
true_pi = p0)
library(epwpl)
dp_result = epwpl::cov_vsvb(X, y, alpha0 = .2, sigmabeta_sq = v_slab,
true_pi = p0)
library(epwpl)
dp_result = epwpl::cov_vsvb(X, y, alpha0 = .2, sigmabeta_sq = v_slab,
true_pi = p0)
S_sq = matrix(sigmasq*(DXtX + 1/sigmabeta_sq)^(-1), n, p) #Initialization
dim(DXtx)
dxTx
DXtX
lengtH(DXtX)
length(DXtX)
sigmasq*(DXtX + 1/sigmabeta_sq)^(-1)
print(n)
print(p)
# compute weights
XtX = t(X) %*% X
XtX
DXtX = diag(XtX)
DXtX_rep = rep(DXtX, p)
DXtX_mat = matrix(DXtX_rep, n*p, p, byrow=FALSE)
Diff_mat = XtX - diag(DXtX)
DXtX_rep
dim(Diff_mat)
DXtX_rep
DXtX
alpha = rep(0.2, n*p) #Initialization of the inclusion probability matrix for a fixed variable, with i th row corresponding to i th subject.
sigmabeta_sq = 3 #Initialization for hyperparameter
mu = rep(0, p) # Variational parameter
true_pi = 0.5 #Hyperparameter
y_long_vec = as.vector(t(y %*% matrix(1, 1, p)))
Xty=t(X) %*% as.vector(y)
beta_mat = matrix(beta, n, p, byrow=TRUE)
mu_mat = beta_mat
D_long = matrix(0, n*p, n)
for( i in 1:n){
D_long[, i] = matrix(t(D[, i] %*% matrix(1, 1, p)), n*p, 1)
}
S_sq = matrix(sigmasq*(DXtX + 1/sigmabeta_sq)^(-1), n, p) #Initialization
iter = 1
ind_vec = seq(0,(n-1)*p,by=p)
Ind_mat = matrix(0,n,p)
for(j in 1:p){
Ind_mat[, j] = ind_vec + j
}
Big_ind = matrix(0, n*p, p)
Big_ind_1 = matrix(0, n*p, p)
for(j in 1:p){
Big_ind[Ind_mat[, j], j] = 1
Big_ind_1[Ind_mat[, j], j] = 0
}
p = 10
sp_index in 1:(p+1)) {
for (i in 1:n) {
beta[i, ] = (t(Lam1[-resp_index]) > 0) * (i <= n/2) +
(t(Lam2[-resp_index]) > 0) * (i > n/2) #Ground truth
for(j in 1:p){
Z[i,j] = -.1*(i <= n/2)  + .1*(i > n/2)
}
}
y = data_mat[, resp_index] #Set variable number `resp_index` as the response
X_mat = data_mat[, -resp_index]
X_vec = matrix(0, n*p, 1)
X = matrix(rep(0, n^2*p), nrow = n, ncol = n*p)
for(i in 1:n) {
for(j in 1:p) {
k = p*(i-1) + 1
X[i, k+j-1] = X_mat[i, j]
X_vec[k+j-1] = X[i, k+j-1]
}
}
ELBO_LBit=rep(0,10000)
Big_diag_mat <- matrix(rep(0,n^2*p),nrow=n,ncol=n*p)
for(i in 1:n){
k=p*(i-1)
for(j in 1:p){
Big_diag_mat[i,k+j]=1
}
}
q = matrix(2, n, 1)
sigmasq = 1 #Initialization of the hyperparameter value
E <- rnorm(n, 0, sigmasq)
# compute weights
XtX = t(X) %*% X
DXtX = diag(XtX)
DXtX_rep = rep(DXtX, p)
DXtX_mat = matrix(DXtX_rep, n*p, p, byrow=FALSE)
Diff_mat = XtX - diag(DXtX)
D = matrix(1, n, n)
for(i in 1:n){
for(j in 1:n){
D[i, j] = dnorm(norm(Z[i, ] - Z[j, ], "2"), 0, .1)
}
}
for(i in 1:n){
D[, i] = n * (D[, i] / sum(D[, i])) #Scaling the weights so that they add up to n
# D[,i]=1 # When there is no covariate information, set the weights to be 1 throughout.
}
alpha = rep(0.2, n*p) #Initialization of the inclusion probability matrix for a fixed variable, with i th row corresponding to i th subject.
sigmabeta_sq = 3 #Initialization for hyperparameter
mu = rep(0, p) # Variational parameter
true_pi = 0.5 #Hyperparameter
y_long_vec = as.vector(t(y %*% matrix(1, 1, p)))
Xty=t(X) %*% as.vector(y)
beta_mat = matrix(beta, n, p, byrow=TRUE)
mu_mat = beta_mat
D_long = matrix(0, n*p, n)
for( i in 1:n){
D_long[, i] = matrix(t(D[, i] %*% matrix(1, 1, p)), n*p, 1)
}
S_sq = matrix(sigmasq*(DXtX + 1/sigmabeta_sq)^(-1), n, p) #Initialization
iter = 1
ind_vec = seq(0,(n-1)*p,by=p)
Ind_mat = matrix(0,n,p)
for(j in 1:p){
Ind_mat[, j] = ind_vec + j
}
Big_ind = matrix(0, n*p, p)
Big_ind_1 = matrix(0, n*p, p)
for(j in 1:p){
Big_ind[Ind_mat[, j], j] = 1
Big_ind_1[Ind_mat[, j], j] = 0
}
Big_ind
View(Big_ind)
DXtX_Big_ind = DXtX_mat * Big_ind
DXtX_Big_ind
View(DXtX_Big_ind)
DXtX_mat
DXtX_rep
DXtX
for (i in 1:n) {
beta[i, ] = (t(Lam1[-resp_index]) > 0) * (i <= n/2) +
(t(Lam2[-resp_index]) > 0) * (i > n/2) #Ground truth
for(j in 1:p){
Z[i,j] = -.1*(i <= n/2)  + .1*(i > n/2)
}
}
y = data_mat[, resp_index] #Set variable number `resp_index` as the response
X_mat = data_mat[, -resp_index]
X_vec = matrix(0, n*p, 1)
X = matrix(rep(0, n^2*p), nrow = n, ncol = n*p)
for(i in 1:n) {
for(j in 1:p) {
k = p*(i-1) + 1
X[i, k+j-1] = X_mat[i, j]
X_vec[k+j-1] = X[i, k+j-1]
}
}
ELBO_LBit=rep(0,10000)
Big_diag_mat <- matrix(rep(0,n^2*p),nrow=n,ncol=n*p)
for(i in 1:n){
k=p*(i-1)
for(j in 1:p){
Big_diag_mat[i,k+j]=1
}
}
q = matrix(2, n, 1)
sigmasq = 1 #Initialization of the hyperparameter value
E <- rnorm(n, 0, sigmasq)
# compute weights
XtX = t(X) %*% X
DXtX = diag(XtX)
DXtX_rep = rep(DXtX, p)
DXtX_mat = matrix(DXtX_rep, n*p, p, byrow=FALSE)
Diff_mat = XtX - diag(DXtX)
D = matrix(1, n, n)
for(i in 1:n){
for(j in 1:n){
D[i, j] = dnorm(norm(Z[i, ] - Z[j, ], "2"), 0, .1)
}
}
for(i in 1:n){
D[, i] = n * (D[, i] / sum(D[, i])) #Scaling the weights so that they add up to n
# D[,i]=1 # When there is no covariate information, set the weights to be 1 throughout.
}
alpha = rep(0.2, n*p) #Initialization of the inclusion probability matrix for a fixed variable, with i th row corresponding to i th subject.
sigmabeta_sq = 3 #Initialization for hyperparameter
mu = rep(0, p) # Variational parameter
true_pi = 0.5 #Hyperparameter
y_long_vec = as.vector(t(y %*% matrix(1, 1, p)))
Xty=t(X) %*% as.vector(y)
beta_mat = matrix(beta, n, p, byrow=TRUE)
mu_mat = beta_mat
D_long = matrix(0, n*p, n)
for( i in 1:n){
D_long[, i] = matrix(t(D[, i] %*% matrix(1, 1, p)), n*p, 1)
}
S_sq = matrix(sigmasq*(DXtX + 1/sigmabeta_sq)^(-1), n, p) #Initialization
iter = 1
ind_vec = seq(0,(n-1)*p,by=p)
Ind_mat = matrix(0,n,p)
for(j in 1:p){
Ind_mat[, j] = ind_vec + j
}
Big_ind = matrix(0, n*p, p)
Big_ind_1 = matrix(0, n*p, p)
for(j in 1:p){
Big_ind[Ind_mat[, j], j] = 1
Big_ind_1[Ind_mat[, j], j] = 0
}
DXtX_Big_ind = DXtX_mat * Big_ind
candL = seq(0.1, 0.9, .2)# Different values of hyperparameter true_pi
#candL=0.5
like = rep(0, length(candL))
elb = like
est_pi = rep(0, n)
est_q = est_pi
beta_matr = matrix(0, n, p)
####################tuning hyperparameters##################################
idmod = varbvs::varbvs(X_mat, y, Z=Z[, 1], verbose = FALSE)#Setting hyperparameter value as in Carbonetto Stephens model
inprob = idmod$pip
rest_index_set = setdiff(c(1:(p+1)), resp_index)
sigmasq = mean(idmod$sigma)
pi_est = mean(1 / (1 + exp(-idmod$logodds)))
sigmavec = c(0.01, 0.05, 0.1, 0.5, 1, 3, 7, 10)
elb1 = matrix(0, length(sigmavec), 1)
for (j in 1:length(sigmavec)) {
res = epwpl::cov_vsvb(y, X, Z, XtX, DXtX, Diff_mat, Xty, sigmasq, sigmavec[j], pi_est)
elb1[j] = res$var.elbo
}
sigmabeta_sq = sigmavec[which.max(elb1)] #Choosing hyperparameter based on ELBO maximization
result = cov_vsvb(y, X, Z, XtX, DXtX, Diff_mat, Xty, sigmasq, sigmabeta_sq, pi_est)
incl_prob = result$var.alpha
mu0_val = result$var.mu0_lambda
heat_alpha = matrix(incl_prob, n, p, byrow=TRUE)
mylist[[resp_index]] = heat_alpha
}
S_sq
length(DXtX_rep)
length(DXtX)
dim(XtX)
dim(X)
n
Big_ind_1
DXtX_mat
View(DXtX_mat)
dim(X)
dim(XtX)
XtX
View(XtX)
?varbvs::varbvs
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
library(epwpl)
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
set.seed(1)
n = 100
p = 10
Lam1 = c(3, 3, 3, 3, rep(0, p-3)) * 5 # For Z[i]=-0.1
Lam2 = Lam1 #Same lambda for both covariate levels, corresponds to covariate independent levels
Var1 = solve(Lam1 %*% t(Lam1) + diag(rep(10, p+1))) #covariance matrix for covariate level 1
Var2 = solve(Lam2 %*% t(Lam2) + diag(rep(10, p+1))) #covariance matrix for covariate level 2
# covariate matrix
Z = matrix(-.1*(1:n <= n/2)  + .1*(1:n > n/2), nrow = n, ncol = p, byrow = FALSE)
# true graph
true_graph = matrix(0, p+1, p+1)
for(i in 1:(p+1)){
for(j in 1:(p+1)){
true_graph[i,j] = (Lam1[i] != 0 & Lam1[j] != 0)
}}
diag(true_graph) = 0
# compute weights
tau = 1  # bandwidth
weight_mat = weight_matrix(n, Z)
# only two covariate levels --> only two weightings
weight_mat_fit = weight_mat[c(1, n), ]
# initial hyperparameter values
sigma0 = 1
p0 = .2
v_slab = 3
n_sim = 50
p
X1 = MASS::mvrnorm(n/2, rep(0, p+1), Var1)
X2 = MASS::mvrnorm(n/2, rep(0, p+1), Var2)
data_mat = rbind(X1, X2)
graphs = wpl_regression(data_mat, weight_mat_fit, sigma0, p0, v_slab, n_threads = 1,
blas_threads = 1)
graphs[[1]]
graphs[[2]]
graphs[[3]]
graphs_vb = wpl_vsvb_regression(data_mat, weight_mat, sigma0, p0, v_slab)
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
library(epwpl)
graphs_vb = wpl_vsvb_regression(data_mat, weight_mat, sigma0, p0, v_slab)
graphs_vb
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
graphs_vb = wpl_vsvb_regression(data_mat, weight_mat, sigma0, p0, v_slab)
graphs_vb = wpl_vsvb_regression(data_mat, weight_mat, sigma0, p0, v_slab)
graphs_vb
length(graphs_vb)
graphs_vb[[1]]
graphs[[1]]
graphs_vb[[1]]
graphs_vb[[2]]
graphs_vb[[3]]
graphs_vb[[4]]
graphs_vb[[5]]
graphs_vb[[6]]
graphs_vb[[7]]
graphs_vb[[8]]
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
graphs_vb = wpl_vsvb_regression(data_mat, weight_mat, sigma0, p0, v_slab)
incl_prob
dim(incl_prob)
length(incl_prob)
incl_prob
heat_alpha
heat_alpha[1,]
heat_alpha[100,]
heat_alpha[99,]
heat_alpha[2,]
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
graphs_vb = wpl_vsvb_regression(data_mat, weight_mat_fit, sigma0, p0, v_slab)
graphs_vb
graphs_vb[[1]]
graphs_vb[[1]][1,]
graphs_vb[[1]][2,]
graphs_vb[[1]][51,]
graphs_vb[[1]][52,]
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
graphs_vb = wpl_vsvb_regression(data_mat, weight_mat_fit, sigma0, p0, v_slab)
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
graphs_vb = wpl_vsvb_regression(data_mat, weight_mat_fit, sigma0, p0, v_slab)
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
graphs_vb = wpl_vsvb_regression(data_mat, weight_mat_fit, sigma0, p0, v_slab)
incl_prob
length(incl_prob)
matrix(incl_prob, n, p, byrow=TRUE)
incl_prob[1:n]
incl_prob[1:(n+1)]
dim(incl_prob)
length(incl_prob)
heat_alpha = matrix(incl_prob, n, p, byrow=TRUE)
heat_alphga
heat_alpha
source('~/Research/ep_weighted_pseduolikelihood/experiment/simulation.R')
