regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 1)
tictoc::toc()
tictoc::tic()
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 4)
tictoc::toc()
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
tictoc::tic()
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 4)
tictoc::toc()
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
tictoc::tic()
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 4)
tictoc::toc()
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
library(epwpl)
tictoc::tic()
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 4)
tictoc::toc()
d = 10
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
result$m
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
tictoc::tic()
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 4)
tictoc::toc()
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
tictoc::tic()
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 4)
tictoc::toc()
regressions
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
tictoc::tic()
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 4)
tictoc::toc()
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
tictoc::tic()
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 4)
tictoc::toc()
regressions[[1]]
regressions[[11]]
regressions[[1]]
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
tictoc::tic()
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 4)
tictoc::toc()
regressions
regressions[[1]]
library(data.table)
setDTthreads(1)
# Parallel control --------------------------------------------------------
# library(future.apply)
library(doFuture)
# registerDoFuture()
# plan(multisession, workers = 4)
# RhpcBLASctl::blas_set_num_threads(1)
library(progressr)
handlers(global = TRUE)
handlers("progress")
# Discrete covariate, independent ------------------------------------------------------
set.seed(1)
n = 100
p = 10
Lam1 = c(3, 3, 3, 3, rep(0, p-3)) * 5 # For Z[i]=-0.1
Lam2 = Lam1 #Same lambda for both covariate levels, corresponds to covariate independent levels
Var1 = solve(Lam1 %*% t(Lam1) + diag(rep(10, p+1))) #covariance matrix for covariate level 1
Var2 = solve(Lam2 %*% t(Lam2) + diag(rep(10, p+1))) #covariance matrix for covariate level 2
X1 = MASS::mvrnorm(n/2, rep(0, p+1), Var1)
X2 = MASS::mvrnorm(n/2, rep(0, p+1), Var2)
data_mat = rbind(X1, X2)
# covariate matrix
Z = matrix(-.1*(1:n <= n/2)  + .1*(1:n > n/2), nrow = n, ncol = p, byrow = FALSE)
# compute weights
tau = 1  # bandwidth
D = matrix(1, n, n)
for(i in 1:n){
for(j in 1:n){
D[i, j] = dnorm(norm(Z[i, ] - Z[j, ], "2"), 0, tau)
}
}
for(i in 1:n){
D[, i] = n * (D[, i] / sum(D[, i])) #Scaling the weights so that they add up to n
# D[,i]=1 # When there is no covariate information, set the weights to be 1 throughout.
}
# true graph
beta = matrix(0, p+1, p+1)
for(i in 1:(p+1)){
for(j in 1:(p+1)){
beta[i,j] = (Lam1[i] != 0 & Lam1[j] != 0)
}}
diag(beta) = 0
# initial hyperparameter values
sigma0 = 1
p0 = .2
v_slab = 3
n_sim = 50
tictoc::tic()
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 4)
tictoc::toc()
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
regressions[[1]]
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
tictoc::tic()
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 4)
tictoc::toc()
regressions[[1]]
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
tictoc::tic()
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 1)
tictoc::toc()
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
tictoc::tic()
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 4)
tictoc::toc()
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
d = 1000
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
w = c(1, rep(1, 10), rep(0, d-10))
sigma_noise = sqrt(1/10)
y = rnorm(n, X %*% w, sigma_noise)
plot(X[, 2], y)
plot(X[, 3], y)
plot(X[, 100], y)
plot(X[, 300], y)
plot(X[, 3], y)
sigma_noise
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
v_slab = .1
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
result
result$m
plot(result$m)
plot(result$p)
plot(plogis(result$p))
tictoc::tic()
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
tictoc::toc()
tictoc::tic()
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
tictoc::toc()
d = 10
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
tictoc::tic()
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
tictoc::toc()
.1 * 11 * 100 * 50
.1 * 11 * 100 * 50 / (60)
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
tictoc::tic()
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 1,
blas_threads = 4)
tictoc::toc()
tictoc::tic()
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 4,
blas_threads = 4)
tictoc::toc()
n_sim = 2
regressions[[1]]
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
tictoc::tic()
sim_accuracy = rbindlist(
lapply(1:n_sim, function(sim_idx) {
print(paste0(" --- Simulation ", sim_idx, " ---"))
# fit the n x p regression models
graphs = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 1,
blas_threads = 4)
# compute accuracy metrics
metrics = rbindlist(
lapply(graphs, function(graph) {
for(i in 1:(p+1)) {
for(j in i:(p+1)) {
graph[i, j] = mean(c(graph[i, j], graph[j, i]))
graph[j, i] = graph[i, j]
}
}
est_graph = 1 * (graph_prob > 0.5)
data.table(
sensitivity = sum(est_graph & beta) / sum(beta),
specificity = sum(!est_graph & !beta) / sum(!beta),
individual = i,
simulation = sim_idx
)
})
)
return(metrics)
})
)
tictoc::toc()
tictoc::tic()
sim_accuracy = rbindlist(
lapply(1:n_sim, function(sim_idx) {
print(paste0(" --- Simulation ", sim_idx, " ---"))
# fit the n x p regression models
graphs = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 1,
blas_threads = 4)
# compute accuracy metrics
metrics = rbindlist(
lapply(graphs, function(graph) {
for(i in 1:(p+1)) {
for(j in i:(p+1)) {
graph[i, j] = mean(c(graph[i, j], graph[j, i]))
graph[j, i] = graph[i, j]
}
}
est_graph = 1 * (graph > 0.5)
data.table(
sensitivity = sum(est_graph & beta) / sum(beta),
specificity = sum(!est_graph & !beta) / sum(!beta),
individual = i,
simulation = sim_idx
)
})
)
return(metrics)
})
)
tictoc::toc()
library(doFuture)
registerDoFuture()
plan(multisession, workers = 4)
# RhpcBLASctl::blas_set_num_threads(1)
library(progressr)
handlers(global = TRUE)
handlers("progress")
library(doFuture)
registerDoFuture()
plan(multisession, workers = 4)
# RhpcBLASctl::blas_set_num_threads(1)
tictoc::tic()
sim_accuracy = rbindlist(
future_lapply(1:n_sim, function(sim_idx) {
print(paste0(" --- Simulation ", sim_idx, " ---"))
# fit the n x p regression models
graphs = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 1,
blas_threads = 4)
# compute accuracy metrics
metrics = rbindlist(
lapply(graphs, function(graph) {
for(i in 1:(p+1)) {
for(j in i:(p+1)) {
graph[i, j] = mean(c(graph[i, j], graph[j, i]))
graph[j, i] = graph[i, j]
}
}
est_graph = 1 * (graph > 0.5)
data.table(
sensitivity = sum(est_graph & beta) / sum(beta),
specificity = sum(!est_graph & !beta) / sum(!beta),
individual = i,
simulation = sim_idx
)
})
)
return(metrics)
})
)
tictoc::toc()
# library(future.apply)
library(doFuture)
registerDoFuture()
plan(multisession, workers = 4)
tictoc::tic()
sim_accuracy = rbindlist(
future_lapply(1:n_sim, function(sim_idx) {
print(paste0(" --- Simulation ", sim_idx, " ---"))
# fit the n x p regression models
graphs = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 1,
blas_threads = 1)
# compute accuracy metrics
metrics = rbindlist(
lapply(graphs, function(graph) {
for(i in 1:(p+1)) {
for(j in i:(p+1)) {
graph[i, j] = mean(c(graph[i, j], graph[j, i]))
graph[j, i] = graph[i, j]
}
}
est_graph = 1 * (graph > 0.5)
data.table(
sensitivity = sum(est_graph & beta) / sum(beta),
specificity = sum(!est_graph & !beta) / sum(!beta),
individual = i,
simulation = sim_idx
)
})
)
return(metrics)
})
)
tictoc::toc()
n_sim
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
Sys.time()
progressr::with_progress({
prog = progressr::progressor(along = 1:n)
sim_accuracy = rbindlist(
future_lapply(1:n_sim, function(sim_idx) {
prog(sprintf("Simulation %g, Sys.time()", sim_idx))
# print(paste0(" --- Simulation ", sim_idx, " ---"))
# fit the n x p regression models
graphs = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 1,
blas_threads = 1)
# compute accuracy metrics
metrics = rbindlist(
lapply(graphs, function(graph) {
# symmetrize estimated graph
for(i in 1:(p+1)) {
for(j in i:(p+1)) {
graph[i, j] = mean(c(graph[i, j], graph[j, i]))
graph[j, i] = graph[i, j]
}
}
est_graph = 1 * (graph > 0.5)
data.table(
sensitivity = sum(est_graph & beta) / sum(beta),
specificity = sum(!est_graph & !beta) / sum(!beta),
individual = i,
simulation = sim_idx
)
})
)
return(metrics)
})
)
})
progressr::with_progress({
prog = progressr::progressor(along = 1:n)
sim_accuracy = rbindlist(
future_lapply(1:n_sim, function(sim_idx) {
prog(sprintf("Simulation %g, %s", sim_idx, Sys.time()))
# print(paste0(" --- Simulation ", sim_idx, " ---"))
# fit the n x p regression models
graphs = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 1,
blas_threads = 1)
# compute accuracy metrics
metrics = rbindlist(
lapply(graphs, function(graph) {
# symmetrize estimated graph
for(i in 1:(p+1)) {
for(j in i:(p+1)) {
graph[i, j] = mean(c(graph[i, j], graph[j, i]))
graph[j, i] = graph[i, j]
}
}
est_graph = 1 * (graph > 0.5)
data.table(
sensitivity = sum(est_graph & beta) / sum(beta),
specificity = sum(!est_graph & !beta) / sum(!beta),
individual = i,
simulation = sim_idx
)
})
)
return(metrics)
})
)
})
sim_accuracy
graphs
dim(data_mat)
cov_indep = readRDS("data/2021-05-26_covariate_independent.RDS")
dim(cov_indep)
cov_indep
cov_indep_long = melt(cov_indep, id.vars = c("individual", "simulation"))
View(Var2)
cov_indep_long
ggplot(cov_indep, aes(x = value)) +
geom_boxplot() +
facet_wrap(vars(variable))
library(ggplot2)
ggplot(cov_indep, aes(x = value)) +
geom_boxplot() +
facet_wrap(vars(variable))
cov_indep
ggplot(cov_indep_long, aes(x = value)) +
geom_boxplot() +
facet_wrap(vars(variable))
summary(cov_indep$sensitivity)
boxplot(cov_indep_long, value ~ variable)
cov_indep_long
ggplot(cov_indep_long, aes(x = value)) +
geom_boxplot() +
facet_wrap(vars(variable))
ggplot(cov_indep_long, aes(x = value)) +
geom_boxplot() +
facet_wrap(vars(variable)) +
coord_flip()
no_cov = readRDS("data/2021-05-26_no_covariate.RDS")
View(cov_indep)
no_cov
no_cov_long = melt(no_cov, id.vars = c("individual", "simulation"))
ggplot(no_cov_long, aes(x = value)) +
geom_boxplot() +
facet_wrap(vars(variable)) +
coord_flip()
cov_dep = readRDS("data/2021-05-26_p=10_dependent_covariate.RDS")
cov_dep_long = melt(cov_dep, id.vars = c("individual", "simulation"))
cov_dep_long
cov_indep_long
cov_dep_long = melt(cov_dep, id.vars = c("individual", "simulation", "p"))
cov_dep_long
ggplot(cov_dep_long, aes(x = value)) +
geom_boxplot() +
facet_wrap(vars(variable)) +
coord_flip()
n = 180
p = 4
MAXITER = 1
STR = 1
in_pr_13 = matrix(0, MAXITER, n)
in_pr_12 = in_pr_13
Var_cont = function(z) {
pr = matrix(0, p+1, p+1)
diag(pr) = 2
#  pr[1,2]=STR*((z>0) && (z< .33)) + (STR - STR*((z-.33)/.33))*((z>0.33) && (z<0.66)) + (0)*((z>0.66) && (z<1))
#  pr[1,3]=0*((z>0) && (z< .33)) + (STR*((z-.33)/.33))*((z>0.33) && (z<0.66)) + (STR)*((z>0.66) && (z<1))
pr[2,3] = STR
pr[1,2] = STR*((z>-1) && (z< -.33)) + (STR - STR*((z+.23)/.56)) * ((z>-0.23) && (z<0.33)) + (0)*((z>0.43) && (z<1))
pr[1,3] = 0*((z>-1) && (z< -.33)) + (STR*((z+.23)/.56)) * ((z>-0.23) && (z<0.33)) + (STR)*((z>0.43) && (z<1))
pr[2,1] = pr[1,2]
pr[3,1] = pr[1,3]
pr[3,2] = pr[2,3]
Var = solve(pr)
return(Var)
}
Var_cont
sensitivity_20 = matrix(0, MAXITER, 1)
specificity_20 = sensitivity_20
sensitivity_90 = sensitivity_20
specificity_90 = sensitivity_20
sensitivity_160 = sensitivity_20
specificity_160 = sensitivity_20
Z = c(seq(-0.99, -0.331, (-.331+.99)/59),
seq(-0.229,0.329,(.329+.229)/59),
seq(0.431,.99,(.99-.431)/59))
# Z=seq(0.01,.99,.98/(n-1))
Z = matrix(Z, n, 1)
X = matrix(0, n, p+1)
for(i in 1:n) {
X[i, ] = mvrnorm(1, rep(0, p+1), Var_cont(Z[i]))
}
sensitivity_20 = matrix(0, MAXITER, 1)
specificity_20 = sensitivity_20
sensitivity_90 = sensitivity_20
specificity_90 = sensitivity_20
sensitivity_160 = sensitivity_20
specificity_160 = sensitivity_20
Z = c(seq(-0.99, -0.331, (-.331+.99)/59),
seq(-0.229,0.329,(.329+.229)/59),
seq(0.431,.99,(.99-.431)/59))
# Z=seq(0.01,.99,.98/(n-1))
Z = matrix(Z, n, 1)
X = matrix(0, n, p+1)
for(i in 1:n) {
X[i, ] = MASS::mvrnorm(1, rep(0, p+1), Var_cont(Z[i]))
}
beta
cov_dep
View(cov_dep)
