library(future.apply)
plan(multisession, workers = 4)
setDTthreads(1)
RhpcBLASctl::blas_set_num_threads(1)
X
dim(X)
data_mat
wpl_regression = function(data_mat, weight_mat, sigma0, p0, v_slab, n_threads = 1) {
p = ncol(data_mat)
prog = progressr::progressor(along = 1:(p+1))
regressions = future.apply::future_lapply(1:(p+1), function(resp_idx) {
prog(sprintf("Covariate =%g", resp_idx))
y = data_mat[, resp_idx]
X = data_mat[, -resp_idx]
incl_prob = sapply(1:n, function(i) {
sq_weights = sqrt(D[i, ])
y_weighted = y * sq_weights
X_weighted = X * sq_weights
# fit model
fit = epwpl::ep_wlr(X_weighted, y_weighted, sigma0, p0, v_slab)
t(plogis(fit$p))
})
return(incl_prob)
})
return(regressions)
}
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
library(data.table)
# Parallel control --------------------------------------------------------
library(future.apply)
plan(multisession, workers = 4)
setDTthreads(1)
RhpcBLASctl::blas_set_num_threads(1)
library(progressr)
handlers(global = TRUE)
handlers("progress")
# Discrete covariate, independent ------------------------------------------------------
set.seed(1)
n = 100
p = 10
Lam1 = c(3, 3, 3, 3, rep(0, p-3)) * 5 # For Z[i]=-0.1
Lam2 = Lam1 #Same lambda for both covariate levels, corresponds to covariate independent levels
Var1 = solve(Lam1 %*% t(Lam1) + diag(rep(10, p+1))) #covariance matrix for covariate level 1
Var2 = solve(Lam2 %*% t(Lam2) + diag(rep(10, p+1))) #covariance matrix for covariate level 2
X1 = MASS::mvrnorm(n/2, rep(0, p+1), Var1)
X2 = MASS::mvrnorm(n/2, rep(0, p+1), Var2)
data_mat = rbind(X1, X2)
# covariate matrix
Z = matrix(-.1*(1:n <= n/2)  + .1*(1:n > n/2), nrow = n, ncol = p, byrow = FALSE)
# compute weights
tau = 1  # bandwidth
D = matrix(1, n, n)
for(i in 1:n){
for(j in 1:n){
D[i, j] = dnorm(norm(Z[i, ] - Z[j, ], "2"), 0, tau)
}
}
for(i in 1:n){
D[, i] = n * (D[, i] / sum(D[, i])) #Scaling the weights so that they add up to n
# D[,i]=1 # When there is no covariate information, set the weights to be 1 throughout.
}
# true graph
beta = matrix(0, p+1, p+1)
for(i in 1:(p+1)){
for(j in 1:(p+1)){
beta[i,j] = (Lam1[i] != 0 & Lam1[j] != 0)
}}
diag(beta) = 0
# initial hyperparameter values
sigma0 = 1
p0 = .2
v_slab = 3
n_sim = 50
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 4)
# Parallel control --------------------------------------------------------
# library(future.apply)
library(doFuture)
registerDoFuture()
plan(multisession, workers = 4)
library(data.table)
setDTthreads(1)
# Parallel control --------------------------------------------------------
# library(future.apply)
library(doFuture)
registerDoFuture()
plan(multisession, workers = 4)
RhpcBLASctl::blas_set_num_threads(1)
library(doFuture)
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
library(data.table)
setDTthreads(1)
# Parallel control --------------------------------------------------------
# library(future.apply)
library(doFuture)
registerDoFuture()
plan(multisession, workers = 4)
RhpcBLASctl::blas_set_num_threads(1)
library(progressr)
handlers(global = TRUE)
handlers("progress")
# Discrete covariate, independent ------------------------------------------------------
set.seed(1)
n = 100
p = 10
Lam1 = c(3, 3, 3, 3, rep(0, p-3)) * 5 # For Z[i]=-0.1
Lam2 = Lam1 #Same lambda for both covariate levels, corresponds to covariate independent levels
Var1 = solve(Lam1 %*% t(Lam1) + diag(rep(10, p+1))) #covariance matrix for covariate level 1
Var2 = solve(Lam2 %*% t(Lam2) + diag(rep(10, p+1))) #covariance matrix for covariate level 2
X1 = MASS::mvrnorm(n/2, rep(0, p+1), Var1)
X2 = MASS::mvrnorm(n/2, rep(0, p+1), Var2)
data_mat = rbind(X1, X2)
# covariate matrix
Z = matrix(-.1*(1:n <= n/2)  + .1*(1:n > n/2), nrow = n, ncol = p, byrow = FALSE)
# compute weights
tau = 1  # bandwidth
D = matrix(1, n, n)
for(i in 1:n){
for(j in 1:n){
D[i, j] = dnorm(norm(Z[i, ] - Z[j, ], "2"), 0, tau)
}
}
for(i in 1:n){
D[, i] = n * (D[, i] / sum(D[, i])) #Scaling the weights so that they add up to n
# D[,i]=1 # When there is no covariate information, set the weights to be 1 throughout.
}
# true graph
beta = matrix(0, p+1, p+1)
for(i in 1:(p+1)){
for(j in 1:(p+1)){
beta[i,j] = (Lam1[i] != 0 & Lam1[j] != 0)
}}
diag(beta) = 0
# initial hyperparameter values
sigma0 = 1
p0 = .2
v_slab = 3
n_sim = 50
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 4)
regressions
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 1)
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
library(doFuture)
wpl_regression = function(data_mat, weight_mat, sigma0, p0, v_slab, n_threads = 1) {
registerDoFuture()
plan(multisession, workers = n_threads)
RhpcBLASctl::blas_set_num_threads(1)
p = ncol(data_mat)
progressr::with_progress({
prog = progressr::progressor(along = 1:(p+1))
regressions = future.apply::future_lapply(1:(p+1), function(resp_idx) {
prog(sprintf("Covariate =%g", resp_idx))
y = data_mat[, resp_idx]
X = data_mat[, -resp_idx]
incl_prob = sapply(1:n, function(i) {
sq_weights = sqrt(D[i, ])
y_weighted = y * sq_weights
X_weighted = X * sq_weights
# fit model
fit = epwpl::ep_wlr(X_weighted, y_weighted, sigma0, p0, v_slab)
t(plogis(fit$p))
})
return(incl_prob)
})
})
return(regressions)
}
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 1)
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 4)
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
dim(data_mat)
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
tictoc::tic()
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 1)
tictoc::toc()
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
tictoc::tic()
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 4)
tictoc::toc()
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
tictoc::tic()
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 4)
tictoc::toc()
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
tictoc::tic()
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 4)
tictoc::toc()
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
tictoc::tic()
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 4)
tictoc::toc()
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
260 * 50
260 * 50 / 60
260 * 50 / (60 / 60)
260 * 50 / (60 * 60)
260 * 50 / (60 * 60 * 4)
260 * 50 / (60 * 60 * 8)
260 * 50 / (60 * 60 * 14)
?dfoptim::nmkb
library(epwpl)
d = 10
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
result$m
library(epwpl)
d = 10
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
result$m
library(epwpl)
d = 10
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
result$m
library(epwpl)
d = 10
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
result$m
library(epwpl)
d = 10
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
result$m
# My own example ----------------------------------------------------------
d = 10
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
result$m
library(epwpl)
d = 10
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
result$m
m_site1
library(epwpl)
d = 10
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
m_site1
sigm_mp_site3_dnorm
sigm_p_site3
yty
v_site1
library(epwpl)
d = 10
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
d = 10
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
v_site1
library(epwpl)
d = 10
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
v_site1
library(epwpl)
d = 10
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
library(epwpl)
d = 10
n = 100
X = cbind(1, mvtnorm::rmvnorm(n, rep(0, d), 5.*diag(d) + .5*rep(1, d) %*% t(rep(1, d))))
v_slab = .1
# z = rbinom(d, 1, p0)
# z = c(1, rep(0, d))
# w = rep(0, d)
# w[z == 1] = rnorm(sum(z == 1), 0, sqrt(v_slab))
w = c(1, 1, rep(0, d-1))
sigma_noise = sqrt(1/10)
# sigma_noise = .1
y = rnorm(n, X %*% w, sigma_noise)
p0 = .1
weights = rep(1, n)
sigma0 = sqrt(1)
result = epwpl::ep_wlr(X, y, sigma0, p0, v_slab, max_iter = 2000)
result
library(data.table)
setDTthreads(1)
# Parallel control --------------------------------------------------------
# library(future.apply)
library(doFuture)
# registerDoFuture()
# plan(multisession, workers = 4)
# RhpcBLASctl::blas_set_num_threads(1)
library(progressr)
handlers(global = TRUE)
handlers("progress")
# Discrete covariate, independent ------------------------------------------------------
set.seed(1)
n = 100
p = 10
Lam1 = c(3, 3, 3, 3, rep(0, p-3)) * 5 # For Z[i]=-0.1
Lam2 = Lam1 #Same lambda for both covariate levels, corresponds to covariate independent levels
Var1 = solve(Lam1 %*% t(Lam1) + diag(rep(10, p+1))) #covariance matrix for covariate level 1
Var2 = solve(Lam2 %*% t(Lam2) + diag(rep(10, p+1))) #covariance matrix for covariate level 2
X1 = MASS::mvrnorm(n/2, rep(0, p+1), Var1)
X2 = MASS::mvrnorm(n/2, rep(0, p+1), Var2)
data_mat = rbind(X1, X2)
# covariate matrix
Z = matrix(-.1*(1:n <= n/2)  + .1*(1:n > n/2), nrow = n, ncol = p, byrow = FALSE)
# compute weights
tau = 1  # bandwidth
D = matrix(1, n, n)
for(i in 1:n){
for(j in 1:n){
D[i, j] = dnorm(norm(Z[i, ] - Z[j, ], "2"), 0, tau)
}
}
for(i in 1:n){
D[, i] = n * (D[, i] / sum(D[, i])) #Scaling the weights so that they add up to n
# D[,i]=1 # When there is no covariate information, set the weights to be 1 throughout.
}
# true graph
beta = matrix(0, p+1, p+1)
for(i in 1:(p+1)){
for(j in 1:(p+1)){
beta[i,j] = (Lam1[i] != 0 & Lam1[j] != 0)
}}
diag(beta) = 0
# initial hyperparameter values
sigma0 = 1
p0 = .2
v_slab = 3
n_sim = 50
tictoc::tic()
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 1)
tictoc::toc()
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
tictoc::tic()
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 1)
tictoc::toc()
library(future.apply)
source('~/Research/ep_weighted_pseudolik/epwpl/experiment/simulation.R')
tictoc::tic()
regressions = wpl_regression(data_mat, D, sigma0, p0, v_slab, n_threads = 1)
tictoc::toc()
matrix(1, 1, p)
y
y %*% matrix(1, 1 p)
y %*% matrix(1, 1, p)
dim(y %*% matrix(1, 1, p))
dim(y)
length(y)
